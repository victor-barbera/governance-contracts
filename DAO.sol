//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import "./Polling.sol";
import "./IMonetaryToken.sol";
import "./GovernanceToken.sol";
import "./RoleNFT.sol";

/**
 * @title Polling Contract
 * @author Víctor Barberà
 * @notice Simple SC from scratch for a fully customized DAO that requires a set of
 *  features. Specifically, the DAO is intended to be used as a expenses management tool
 *  for a residents association.
 */
/* TODO:
        * Gestio del $Governance   [X]
        * Gestio del NFT           [X]
        * Gestionar decimals       [X]
        * Seguir el standart de _  [ ]
        * Natspec a tot            [ ]
*/
contract DAO is Polling {
    /* Ara mateic els rols son:
                * ADMIN: El president, pot crear polls i transferir nfts.
                * TOKENMANAGER: Encarregat de gestionar el token de governança.
    */

    enum Role {ADMIN, TOKENMANAGER}
    struct TokenBlocked {
        address addr;
        uint qty;
    }
    address private _monetaryTokenAddr;
    GovernanceToken private _governanceTokenContract;
    RoleNFT private _roleContract;
    mapping(uint => TokenBlocked[]) internal _blockedTokenOnProposals;

    constructor(address monetaryTokenAddr_) {
        _monetaryTokenAddr = monetaryTokenAddr_;
        _governanceTokenContract = new GovernanceToken();
        _roleContract = new RoleNFT();
        _roleContract.mint(msg.sender, uint(Role.ADMIN));
        _roleContract.mint(address(this), uint(Role.TOKENMANAGER));
    }

    modifier hasRole(Role role) {
        require(_roleContract.ownerOf(uint(role)) == msg.sender,"Acces denied");
        _;
    }

    // SECTION  -  Polling functions

    /**
     * @notice Extends `createPoll()` functionality from Polling SC, adding the
     *  conditions to vote, more concretly checking that caller holds the PresidentNFT.
     * @dev The params are descrived in the `vote()` function of the Polling SC 
     *  and the `TransferWithAuthorization()`of MonetaryToken SC.
     */
    function createPoll(string memory _title, string memory _description, address _destAddr, uint _qty) public override hasRole(Role.ADMIN) returns (uint256 _id) {
        uint8 tokenDecimals = IMonetaryToken(_monetaryTokenAddr).decimals();
        uint256 tokenQty = _qty * 10 ** tokenDecimals;
        return super.createPoll(_title,_description,_destAddr,tokenQty);
    }

    /// @dev Disabled function.
    function vote(uint _pollId, Options _value, uint weight) public pure override {
        revert("vote() function disabled, use voteWithDeposit() instead");
    }

    /**
     * @notice Extends `vote()` functionality from Polling SC, adding the deposit
     *  signature param wich will be used to send the token to a vault until
     *  the vote ends. If the proposal is rejected the funds will be returned
     *  to the voter. It's not rquired that the token signature is generated by
     *  the voter (this means that anyone can pay on your behalf by sending you
     *  the signed message).
     * @dev The params are descrived in the `vote()` function of
     *  the Polling SC and the `TransferWithAuthorization()`of MonetaryToken SC.
     */
    /* TODO:
            * Get user weight        [X]
            * Guardar Tx al mapping  [X]
            * Check _to és la DAO    [X]
            * Weight al vot tmb      [X]
    */
    function voteWithDeposit(
        uint _pollId,
        Options _value,
        address _from,
        address _to,
        uint256 _qty,
        uint256 _validAfter,
        uint256 _validBefore,
        bytes32 _nonce,
        uint8 _v,
        bytes32 _r,
        bytes32 _s
        ) external {
            require(_to == address(this), "Incorrect destination of the Tx");
            uint weight = _getWeight();
            require(_qty >= polls[_pollId].qty * weight/_governanceTokenContract.totalSupply(), "Insufficient token amount");
            IMonetaryToken(_monetaryTokenAddr).transferWithAuthorization(_from, _to, _qty, _validAfter, _validBefore, _nonce, _v, _r, _s);
            _blockedTokenOnProposals[_pollId].push(TokenBlocked(_from, _qty));
            super.vote(_pollId, _value, weight);
    }

    /* TODO:
            * Mirar si tothom a votat   [ ]
            * Mirar que fer amb exedent [ ]
    */
    function evaluatePoll(uint _pollId) public override pollExists(_pollId) returns (Options _result) {
        require((polls[_pollId].createdAt + duration) < block.timestamp,"This poll hasn't ended yet");
        uint blockedToken = _getBlockedToken(_pollId);
        if(blockedToken >= polls[_pollId].qty) {
            _result = super.evaluatePoll(_pollId);
            if(_result == Options.YES) IMonetaryToken(_monetaryTokenAddr).transfer(polls[_pollId].destAddr, polls[_pollId].qty);
            else _returnBlockedToken(_pollId);
        } else {
            _result = Options.NO;
            polls[_pollId].result = _result;
            _returnBlockedToken(_pollId);
        }
    }

    function _getBlockedToken(uint _pollId) private view returns (uint tokenBlocked){
        TokenBlocked[] memory t = _blockedTokenOnProposals[_pollId];
        for(uint i = 0; i < t.length; i++) {
            tokenBlocked += t[i].qty;
        }
    }

    function _returnBlockedToken(uint _pollId) private {
        TokenBlocked[] memory t = _blockedTokenOnProposals[_pollId];
        for(uint i = 0; i < t.length; i++) {
            IMonetaryToken(_monetaryTokenAddr).transfer(t[i].addr, t[i].qty);
        }
    }

    function _getWeight() private view returns (uint){
        return _governanceTokenContract.balanceOf(msg.sender);
    }

    // SECTION  -  Governance Token and Role NFT functions

    function mintProperty(address to, uint amount) external hasRole(Role.TOKENMANAGER) {
        _governanceTokenContract.mint(to, amount);
    }
    function burnTokens(address from, uint amount) external hasRole(Role.TOKENMANAGER) {
        _governanceTokenContract.burn(from, amount);
    }
    function transferProperty(address from, address to, uint amount) external hasRole(Role.TOKENMANAGER) {
        _governanceTokenContract.transfer(from, to, amount); // No enviem tot el que te perque pot tenir mes d'una propietat.
    }

    function transferRole(address to, Role role) external hasRole(Role.ADMIN) {
        address from = _roleContract.ownerOf(uint(role));
        _roleContract.transfer(from, to , uint(role));
    }
}